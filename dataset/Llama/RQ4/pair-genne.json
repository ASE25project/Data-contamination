{"description": "Returns the column index of the header. If multiple columns share the same name (bad practice), returns the first which meets the criteria. @param header @return", "code": "private int getColumnIdx(String header) {\n\t\tint idx = 0;\n\t\tboolean found = false;\n\t\tfor(String head: headers) {\n\t\t\tif(head.equals(header)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tidx++;\n\t\t}\n\t\t\t\n\t\tif(!found)\n\t\t\tthrow new IllegalArgumentException(\"no such header: \"+header);\n\t\t\n\t\treturn idx;\n\t}"}
{"description": "Set the indices of row/col to the new value and return the old value @param row @param col @param newValue @return", "code": "public double setEntry(int row, int col, double newValue) {\n\t\tdouble d = getEntry(row, col);\n\t\tthis.data.setEntry(row, col, newValue);\n\t\treturn d;\n\t}"}
{"description": "Verifies that the data was signed with the given signature, and returns the verified purchase. The data is in JSON format and signed with a private key. @param productId the product Id used for debug validation. @param base64PublicKey the base64-encoded public key to use for verifying. @param signedData the signed JSON string (signed, not encrypted) @param signature the signature for the data, signed with the private key", "code": "public static boolean verifyPurchase(String productId, String base64PublicKey, String signedData, String signature) {\n        if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey) ||\n                TextUtils.isEmpty(signature)) {\n\n            if(BuildConfig.DEBUG){\n                //handle test purchase not having signature\n                if(productId.equals(\"android.test.purchased\")) {\n                    return true;\n                }\n            }\n            Log.e(TAG, \"Purchase verification failed: missing data.\");\n            return false;\n        }\n\n        PublicKey key = Security.generatePublicKey(base64PublicKey);\n        return Security.verify(key, signedData, signature);\n    }"}
{"description": "Generates a PublicKey instance from a string containing the Base64-encoded public key. @param encodedPublicKey Base64-encoded public key @throws IllegalArgumentException if encodedPublicKey is invalid", "code": "public static PublicKey generatePublicKey(String encodedPublicKey) {\n        try {\n            byte[] decodedKey = Base64.decode(encodedPublicKey, Base64.DEFAULT);\n            KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);\n            return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (InvalidKeySpecException e) {\n            Log.e(TAG, \"Invalid key specification.\");\n            throw new IllegalArgumentException(e);\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Base64 decoding failed.\");\n            throw e;\n        }\n    }"}
{"description": "Verifies that the signature from the server matches the computed signature on the data. Returns true if the data is correctly signed. @param publicKey public key associated with the developer account @param signedData signed data from server @param signature server signature @return true if the data and signature match", "code": "public static boolean verify(PublicKey publicKey, String signedData, String signature) {\n        Signature sig;\n        try {\n            sig = Signature.getInstance(SIGNATURE_ALGORITHM);\n            sig.initVerify(publicKey);\n            sig.update(signedData.getBytes());\n            if (!sig.verify(Base64.decode(signature, Base64.DEFAULT))) {\n                Log.e(TAG, \"Signature verification failed.\");\n                return false;\n            }\n            return true;\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(TAG, \"NoSuchAlgorithmException.\");\n        } catch (InvalidKeyException e) {\n            Log.e(TAG, \"Invalid key specification.\");\n        } catch (SignatureException e) {\n            Log.e(TAG, \"Signature exception.\");\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Base64 decoding failed.\");\n        }\n        return false;\n    }"}
{"description": "Compares the specified object with this <code>AbstractPair</code> for equality. <p> Returns <code>true</code> if the given object is also a pair with the same components, <code>false</code> otherwise. @return <code>true</code> if the given object is also a pair with the same components, <code>false</code> otherwise.", "code": "public boolean equals (Object o) {\n        return  (o.getClass().equals(this.getClass()) && (((((AbstractPair)o).component1 == null) &&\n                (this.component1 == null)) || ((this.component1 != null) && ((AbstractPair)o).component1.equals(this.component1)))\n                && (((((AbstractPair)o).component2 == null) && (this.component2 == null)) || ((this.component2\n                != null) && ((AbstractPair)o).component2.equals(this.component2))));\n    }"}
{"description": "Return all beans depending directly or indirectly (transitively), on the bean identified by the beanName. When dealing with a FactoryBean, the factory itself can be returned or its product. Additional filtering can be executed through the type parameter. If no filtering is required, then null can be passed. Note that depending on #rawFactoryBeans parameter, the type of the factory or its product can be used when doing the filtering. @param beanFactory beans bean factory @param beanName root bean name @param rawFactoryBeans consider the factory bean itself or the its product @param type type of the beans returned (null to return all beans) @return bean names", "code": "public static String[] getTransitiveDependenciesForBean(ConfigurableListableBeanFactory beanFactory,\r\n\t\t\tString beanName, boolean rawFactoryBeans, Class<?> type) {\r\n\t\tAssert.notNull(beanFactory);\r\n\t\tAssert.hasText(beanName);\r\n\r\n\t\tAssert.isTrue(beanFactory.containsBean(beanName), \"no bean by name [\" + beanName + \"] can be found\");\r\n\r\n\t\tSet<String> beans = new LinkedHashSet<String>(8);\r\n\t\t// used to break cycles between nested beans\r\n\t\tSet<String> innerBeans = new LinkedHashSet<String>(4);\r\n\r\n\t\tgetTransitiveBeans(beanFactory, beanName, rawFactoryBeans, beans, innerBeans);\r\n\r\n\t\tif (type != null) {\r\n\t\t\t// filter by type\r\n\t\t\tfor (Iterator<String> iter = beans.iterator(); iter.hasNext();) {\r\n\t\t\t\tString bean = iter.next();\r\n\t\t\t\tif (!beanFactory.isTypeMatch(bean, type)) {\r\n\t\t\t\t\titer.remove();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn beans.toArray(new String[beans.size()]);\r\n\t}"}
{"description": "Remove the entries in this map having a key that matches the given matcher @param matcher The matcher @return This map with only the keys that don't match the given matcher", "code": "public LambdaMap<K, V> removeKeys(Matcher<?> matcher) {\n        return retainKeys(not(matcher));\n    }"}
{"description": "Retains only the entries in this map having a value that matches the given matcher @param matcher The matcher @return This map without the values that don't match the given matcher", "code": "public LambdaMap<K, V> retainValues(Matcher<?> matcher) {\n        return retain(matcher, false);\n    }"}
{"description": "Returns a shallow copy of this LambdaMap instance. (The elements themselves are not copied.) @return A clone of this LambdaMap instance", "code": "@Override\n    public LambdaMap<K, V> clone() {\n        return clone(new HashMap<K, V>());\n    }"}
{"description": "This will parse the AFM document. This will close the Input stream when the parsing is finished. @return the parsed FontMetric @throws IOException If there is an IO error reading the document.", "code": "public FontMetrics parse() throws IOException\r\n    {\r\n    \treturn parseFontMetric();\r\n    }"}
{"description": "Gets the value of the evidence property. <p> This accessor method returns a reference to the live list, not a snapshot. Therefore any modification you make to the returned list will be present inside the JAXB object. This is why there is not a <CODE>set</CODE> method for the evidence property. <p> For example, to add a new item, do as follows: <pre> getEvidence().add(newItem); </pre> <p> Objects of the following type(s) are allowed in the list {@link Integer }", "code": "public List<Integer> getEvidence() {\n        if (evidence == null) {\n            evidence = new ArrayList<Integer>();\n        }\n        return this.evidence;\n    }"}
{"description": "Registers the given requestURI as a readonly request, as long as it has not been tracked before as a modifying request (via {@link #modifyingRequest(String)}). <p> There's a limit on the number and the time readonly requests are beeing stored (simply a LRU cache), so that the most frequently accessed readonly requests are stored. </p> @param requestId the request uri to track. @return <code>true</code> if the requestURI was stored as readonly, <code>false</code> if it was on the blacklist. @see #modifyingRequest(String)", "code": "public boolean readOnlyRequest( final String requestId ) {\n        if ( !_blacklist.containsKey( requestId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Registering readonly request: \" + requestId );\n            }\n            incrementOrPut( _readOnlyRequests, requestId );\n            return true;\n        }\n        return false;\n    }"}
{"description": "Obtains an instance from a list of trades. @param trades the list of trades @return the portfolio", "code": "public static TradeList of(List<Trade> trades) {\n    return new TradeList(trades);\n  }"}
{"description": "Create a new instance of {@link ScanArgs} with match filter. @param matches the filter @return a new instance of {@link ScanArgs}", "code": "public static ScanArgs matches(String matches) {\n            return new ScanArgs().match(matches);\n        }"}
{"description": "This method uses {@link #createComponents(String, Reader)} to obtain an instance of {@link TokenStreamComponents}. It returns the sink of the components and stores the components internally. Subsequent calls to this method will reuse the previously stored components if and only if the {@link TokenStreamComponents#reset(Reader)} method returned <code>true</code>. Otherwise a new instance of {@link TokenStreamComponents} is created. @param fieldName the name of the field the created TokenStream is used for @param reader the reader the streams source reads from", "code": "@Override\n  public final TokenStream reusableTokenStream(final String fieldName,\n      final Reader reader) throws IOException {\n    TokenStreamComponents streamChain = (TokenStreamComponents)\n    getPreviousTokenStream();\n    if (streamChain == null || !streamChain.reset(reader)) {\n      streamChain = createComponents(fieldName, reader);\n      setPreviousTokenStream(streamChain);\n    }\n    return streamChain.getTokenStream();\n  }"}
{"description": "Resets the encapsulated components with the given reader. This method by default returns <code>true</code> indicating that the components have been reset successfully. Subclasses of {@link ReusableAnalyzerBase} might use their own {@link TokenStreamComponents} returning <code>false</code> if the components cannot be reset. @param reader a reader to reset the source component @return <code>true</code> if the components were reset, otherwise <code>false</code> @throws IOException if the component's reset method throws an {@link IOException}", "code": "protected boolean reset(final Reader reader) throws IOException {\n      source.reset(reader);\n      if(sink != source)\n        sink.reset(); // only reset if the sink reference is different from source\n      return true;\n    }"}
{"description": "Get the number of bytes required to encode this message. Returns the cached size or calls getSerializedSize which sets the cached size. This is used internally when serializing so the size is only computed once. If a member is modified then this could be stale call getSerializedSize if in doubt.", "code": "public int getCachedSize() {\n        if (cachedSize < 0) {\n            // getSerializedSize sets cachedSize\n            getSerializedSize();\n        }\n        return cachedSize;\n    }"}
{"description": "Simple method to get plain HTML or XML data e.g. from custom specialpages or xml newsfeeds. @param url like index.php?title=Main_Page @return HTML content", "code": "public static String getPage(String url) {\n    return getPage(HttpActionClient.of(url));\n  }"}
{"description": "Used to reverse item traversal and layout order. This behaves similar to the layout change for RTL views. When set to true, first item is rendered at the end of the UI, second item is render before it etc. <p/> For horizontal layouts, it depends on the layout direction. When set to true, If {@link android.support.v7.widget.RecyclerView} is LTR, than it will render from RTL, if {@link android.support.v7.widget.RecyclerView}} is RTL, it will render from LTR. <p/> If you are looking for the exact same behavior of {@link android.widget.AbsListView#setStackFromBottom(boolean)}, use {@link #setStackFromEnd(boolean)}", "code": "public void setReverseLayout(boolean reverseLayout) {\n        if (mPendingSavedState != null && mPendingSavedState.mReverseLayout != reverseLayout) {\n            // override pending state\n            mPendingSavedState.mReverseLayout = reverseLayout;\n        }\n        if (reverseLayout == mReverseLayout) {\n            return;\n        }\n        mReverseLayout = reverseLayout;\n        requestLayout();\n    }"}
{"description": "Helper method to call appropriate recycle method depending on current render layout direction @param recycler Current recycler that is attached to RecyclerView @param renderState Current render state. Right now, this object does not change but we may consider moving it out of this view so passing around as a parameter for now, rather than accessing {@link #mRenderState} @see #recycleViewsFromStart(android.support.v7.widget.RecyclerView.Recycler, int) @see #recycleViewsFromEnd(android.support.v7.widget.RecyclerView.Recycler, int)", "code": "private void recycleByRenderState(RecyclerView.Recycler recycler, RenderState renderState) {\n        if (renderState.mLayoutDirection == RenderState.LAYOUT_START) {\n            recycleViewsFromEnd(recycler, renderState.mScrollingOffset);\n        } else {\n            recycleViewsFromStart(recycler, renderState.mScrollingOffset);\n        }\n    }"}
{"description": "Returns the adapter position of the first visible view. <p/> Note that, this value is not affected by layout orientation or item order traversal. ({@link #setReverseLayout(boolean)}). Views are sorted by their positions in the adapter, not in the layout. <p/> If RecyclerView has item decorators, they will be considered in calculations as well. <p/> LinearLayoutManager may pre-cache some views that are not necessarily visible. Those views are ignored in this method. @return The adapter position of the first visible item or {@link RecyclerView#NO_POSITION} if there aren't any visible items. @see #findFirstCompletelyVisibleItemPosition() @see #findLastVisibleItemPosition()", "code": "public int findFirstVisibleItemPosition() {\n        return findOneVisibleChild(0, getChildCount(), false);\n    }"}
{"description": "Returns a {@link Color} given its red, green and blue component values. @param r the red component of the color @param g the green component of the color @param b the blue component of the color @return the {@link Color} matching the given red, green and blue component values", "code": "public static Color getColor(int r, int g, int b) {\r\n\t\treturn getColor(new RGB(r, g, b));\r\n\t}"}
{"description": "Returns <tt>true</tt> if this set contains the specified element. @param element element whose presence in this set is to be tested. @return <tt>true</tt> if this set contains the specified element.", "code": "@Override\r\n  public boolean contains(int element)\r\n  {\r\n    if (element < 0) {\r\n      throw new IndexOutOfBoundsException(\"element < 0: \" + element);\r\n    }\r\n    if (isEmpty()) {\r\n      return false;\r\n    }\r\n    return findElementOrEmpty(element) >= 0;\r\n  }"}
{"description": "Function: addArc Adds an arc to the list of arcs Parameters: node - The node the arc will point towards distance - The distance of the arc from this node to the node it points towards terrain - The terrain in the arc", "code": "public void addArc(GraphNode<E> node, int distance, int terrain) {\n\t\tarcList.add(new Arc<E>(node, distance, terrain));\n\t}"}
{"description": "Provide tuning object with initialized information from properties in the class path or system properties. @param c Tunable class @param <T> type of requested tunable class @return Created and initialized object", "code": "public synchronized static <T extends TunableConstants> T get(Class<T> c) {\n    return getDefault(c);\n  }"}
{"description": "Insert a new course in database.Besides, conflict is detected. This method is intent for inserting a course manually to schedule. Don't call this to insert plenty of courses, inefficiently.If you have to, use {@link #addCourses(List)} instead. @param course The course to be inserted. @return If the inserted course is valid,", "code": "public boolean insertCourse(Course course) {\n\t\tSQLiteDatabase courseDatabase = getWritableDatabase();\n\n\t\tboolean success = false;\n\t\tif (checkConflict(courseDatabase, course) == null) {\n\t\t\taddCourse(courseDatabase, course);\n\t\t\tsuccess = true;\n\t\t}\n\t\tcourseDatabase.close();\n\t\treturn success;\n\t}"}
{"description": "Add a list of courses to the database. Conflict is not detected, so you should make sure the courses don't overlap one anther. This method is used for initializing the schedule, which means to add courses to an empty course table. If you have detected the conflict, use {@link #insertCourse(Course)} instead. @param courses The courses to be added.", "code": "public void addCourses(List<Course> courses) {\n\t\tif (courses != null) {\n\t\t\tSQLiteDatabase courseDatabase = getWritableDatabase();\n\t\t\tfor (Course course : courses) {\n\t\t\t\taddCourse(courseDatabase, course);\n\t\t\t}\n\t\t\tcourseDatabase.close();\n\t\t}\n\t}"}
{"description": "Get authentication for the given name. @param authName The authentication name @return The authentication, null if not found", "code": "public Authentication getAuthentication(String authName) {\n    return authentications.get(authName);\n  }"}
{"description": "Get IWriter instance with default specific format, the IWriter instance can be used to write Java POJO into XML. @param format info about encoding and indent @return an instance of IWriter implementation", "code": "public static IWriter getXMLWriter(Format format) {\r\n\t\treturn new XmlPullWriter(format);\r\n\t}"}
{"description": "Creates a long buffer based on a newly allocated long array. @param capacity the capacity of the new buffer. @return the created long buffer. @throws IllegalArgumentException if {@code capacity} is less than zero.", "code": "public static LongBuffer allocate(int capacity) {\n        if (capacity < 0) {\n            throw new IllegalArgumentException();\n        }\n        return BufferFactory.newLongBuffer(capacity);\n    }"}
{"description": "Returns the long array which this buffer is based on, if there is one. @return the long array which this buffer is based on. @exception ReadOnlyBufferException if this buffer is based on an array, but it is read-only. @exception UnsupportedOperationException if this buffer is not based on an array.", "code": "public final long[] array() {\n        return protectedArray();\n    }"}
{"description": "Returns the offset of the long array which this buffer is based on, if there is one. <p> The offset is the index of the array and corresponds to the zero position of the buffer. @return the offset of the long array which this buffer is based on. @exception ReadOnlyBufferException if this buffer is based on an array, but it is read-only. @exception UnsupportedOperationException if this buffer is not based on an array.", "code": "public final int arrayOffset() {\n        return protectedArrayOffset();\n    }"}
{"description": "Reads longs from the current position into the specified long array and increases the position by the number of longs read. <p> Calling this method has the same effect as {@code get(dest, 0, dest.length)}. @param dest the destination long array. @return this buffer. @exception BufferUnderflowException if {@code dest.length} is greater than {@code remaining()}.", "code": "public LongBuffer get(long[] dest) {\n        return get(dest, 0, dest.length);\n    }"}
{"description": "Indicates whether this buffer is based on a long array and is read/write. @return {@code true} if this buffer is based on a long array and provides read/write access, {@code false} otherwise.", "code": "public final boolean hasArray() {\n        return protectedHasArray();\n    }"}
{"description": "Writes longs from the given long array to the current position and increases the position by the number of longs written. <p> Calling this method has the same effect as {@code put(src, 0, src.length)}. @param src the source long array. @return this buffer. @exception BufferOverflowException if {@code remaining()} is less than {@code src.length}. @exception ReadOnlyBufferException if no changes may be made to the contents of this buffer.", "code": "public final LongBuffer put(long[] src) {\n        return put(src, 0, src.length);\n    }"}
{"description": "Writes longs from the given long array, starting from the specified offset, to the current position and increases the position by the number of longs written. @param src the source long array. @param off the offset of long array, must not be negative and not greater than {@code src.length}. @param len the number of longs to write, must be no less than zero and not greater than {@code src.length - off}. @return this buffer. @exception BufferOverflowException if {@code remaining()} is less than {@code len}. @exception IndexOutOfBoundsException if either {@code off} or {@code len} is invalid. @exception ReadOnlyBufferException if no changes may be made to the contents of this buffer.", "code": "public LongBuffer put(long[] src, int off, int len) {\n        int length = src.length;\n        if (off < 0 || len < 0 || (long) len + (long) off > length) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (len > remaining()) {\n            throw new BufferOverflowException();\n        }\n        for (int i = off; i < off + len; i++) {\n            put(src[i]);\n        }\n        return this;\n    }"}
{"description": "Obtains a template based on the specified index. <p> The period from the start date to the end date will be the tenor of the index. The convention will be created based on the index. @param index the index that defines the market convention @return the template", "code": "public static IborFixingDepositTemplate of(IborIndex index) {\n    return of(index.getTenor().getPeriod(), IborFixingDepositConvention.of(index));\n  }"}
{"description": "Creates a trade based on this template. <p> This returns a trade based on the specified date. The notional is unsigned, with buy/sell determining the direction of the trade. If buying the Ibor fixing deposit, the floating rate is paid from the counterparty, with the fixed rate being received. If selling the Ibor fixing deposit, the floating received is paid to the counterparty, with the fixed rate being paid. @param tradeDate the date of the trade @param buySell the buy/sell flag, see {@link IborFixingDeposit#getBuySell()} @param notional the notional amount, in the payment currency of the template @param fixedRate the fixed rate, typically derived from the market @param refData the reference data, used to resolve the trade dates @return the trade @throws ReferenceDataNotFoundException if an identifier cannot be resolved in the reference data", "code": "public IborFixingDepositTrade createTrade(\n      LocalDate tradeDate,\n      BuySell buySell,\n      double notional,\n      double fixedRate,\n      ReferenceData refData) {\n\n    return convention.createTrade(tradeDate, depositPeriod, buySell, notional, fixedRate, refData);\n  }"}
{"description": "Gets the period between the start date and the end date. <p> The difference between the start date and the end date typically matches the tenor of the index, however this is not validated. @return the value of the property, not null", "code": "public Period getDepositPeriod() {\n    return depositPeriod;\n  }"}
{"description": "Gets the underlying Ibor fixing deposit convention. <p> This specifies the standard convention of the Ibor fixing deposit to be created. @return the value of the property, not null", "code": "public IborFixingDepositConvention getConvention() {\n    return convention;\n  }"}
{"description": "For URI-based (@link ServiceInfo}s which don't conform to the standard URI format, override this method in your own ServiceInfo class to return a {@link UriInfoFactory} which will create the appropriate URIs. @return your special UriInfoFactory", "code": "public UriInfoFactory getUriInfoFactory() {\n\t\treturn uriFactory;\n\t}"}
{"description": "Validate the URI and clean it up by using defaults for any missing information, if possible. @param uriInfo uri info based on parsed payload @return cleaned up uri info", "code": "protected UriInfo validateAndCleanUriInfo(UriInfo uriInfo) {\n\t\treturn uriInfo;\n\t}"}
{"description": "Moves to the start of the next object at the given level in the page hierarchy, and returns false if the end of the page was reached. <p> NOTE that {@link PageIteratorLevel#RIL_SYMBOL} will skip non-text blocks, but all other {@link PageIteratorLevel} level values will visit each non-text block once. Think of non text blocks as containing a single para, with a single line, with a single imaginary word. <p> Calls to {@link #next} with different levels may be freely intermixed. <p> This function iterates words in right-to-left scripts correctly, if the appropriate language has been loaded into Tesseract. @param level the page iterator level. See {@link PageIteratorLevel}. @return {@code false} if the end of the page was reached, {@code true} otherwise.", "code": "public boolean next(int level) {\n        return nativeNext(mNativePageIterator, level);\n    }"}
{"description": "Asynchronous wrapper to item consumption. Works like {@link #consume}, but performs the consumption in the background and notifies completion through the provided listener. This method is safe to call from a UI thread. @param purchase The purchase to be consumed. @param listener The listener to notify when the consumption operation finishes.", "code": "public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener) {\n        checkSetupDone(\"consume\");\n        List<Purchase> purchases = new ArrayList<Purchase>();\n        purchases.add(purchase);\n        consumeAsyncInternal(purchases, listener, null);\n    }"}
{"description": "Gets the index of prices. <p> The pay-off is computed based on this index The most common implementations are provided in {@link PriceIndices}. @return the value of the property, not null", "code": "public PriceIndex getIndex() {\n    return index;\n  }"}
{"description": "Gets reference price index calculation method. <p> This specifies how the reference index calculation occurs. @return the value of the property, not null", "code": "public PriceIndexCalculationMethod getIndexCalculationMethod() {\n    return indexCalculationMethod;\n  }"}
{"description": "Returns a builder that allows this bean to be mutated. @return the mutable builder, not null", "code": "public Builder toBuilder() {\n    return new Builder(this);\n  }"}
{"description": "Sets the positive period between the price index and the accrual date, typically a number of months. <p> A price index is typically published monthly and has a delay before publication. The lag is subtracted from the accrual start and end date to locate the month of the data to be observed. <p> For example, the September data may be published in October or November. A 3 month lag will cause an accrual date in December to be based on the observed data for September, which should be available by then. @param lag the new value, not null @return this, for chaining, not null", "code": "public Builder lag(Period lag) {\n      JodaBeanUtils.notNull(lag, \"lag\");\n      this.lag = lag;\n      return this;\n    }"}
{"description": "Creates a new <code>{@link ShouldHaveSameHourAs}</code>. @param actual the actual value in the failed assertion. @param other the value used in the failed assertion to compare the actual value to. @return the created {@code ErrorMessageFactory}.", "code": "public static ErrorMessageFactory shouldHaveSameHourAs(Temporal actual, Temporal other) {\n        return new ShouldHaveSameHourAs(actual, other);\n    }"}
{"description": "Returns the maximum length a text may have. @return The maximum length a text may have as an {@link Integer} value", "code": "public final int getMaxLength() {\n        return maxLength;\n    }"}
{"description": "Sets the url of the request. Allows null pointers and empty strings, even though it in practice doesn't make any sense. @param url The new url. @return This buildable request instance, allowing chaining of method calls.", "code": "public Builder withUrl(String url) {\n            this.url = url;\n            return this;\n        }"}
{"description": "Sets the response filter logic to use when deciding which response to serve. Null is a valid value, even though it doesn't make sense. @param responseFilter The response filter implementation. @return This buildable request instance, allowing chaining of method calls.", "code": "public Builder withResponseFilter(Response.Filter responseFilter) {\n            this.responseFilter = responseFilter;\n            return this;\n        }"}
{"description": "Puts a key-value pair in the engine bindings. @param key Key. @param value Value. @return Previously assigned value for the key. @see ActionBindings#put(String, Object)", "code": "default <T> T putInBindings(final String key, final T value) {\n\treturn getBindings().put(key, value);\n    }"}
{"description": "Removes a key-value pair from the engine bindings. @param key Key. @return The previously assigned value for this key. @see ActionBindings#remove(String)", "code": "default <T> T removeFromBindings(final String key) {\n\treturn getBindings().remove(key);\n    }"}
{"description": "Schedules an action for immediate execution. @param action Action to schedule. @return Context associated to action (immutable).", "code": "default ActionContext<?> schedule(final Action<?> action) {\n\treturn schedule(action, null);\n    }"}
{"description": "Returns {@code true} if a provider is available, false otherwise. @return {@code true} if a provider is available, false otherwise.", "code": "public boolean isAvailable() {\n        return isAvailable;\n    }"}
{"description": "Returns a specific provider error code. @return The availability error code, or {@code null} if a provider hasn't returned a error code.", "code": "@Nullable\n    public Integer getErrorCode() {\n        return errorCode;\n    }"}
{"description": "The default load balancing policy. <p> The default load balancing policy is {@link DCAwareRoundRobinPolicy} with token awareness (so {@code new TokenAwarePolicy(new DCAwareRoundRobinPolicy())}). @return the default load balancing policy.", "code": "public static LoadBalancingPolicy defaultLoadBalancingPolicy() {\n        // Note: balancing policies are stateful, so we can't store that in a static or that would screw thing\n        // up if multiple Cluster instance are started in the same JVM.\n        return new TokenAwarePolicy(new DCAwareRoundRobinPolicy());\n    }"}
{"description": "The default reconnection policy. <p> The default reconnection policy is an {@link ExponentialReconnectionPolicy} where the base delay is 1 second and the max delay is 10 minutes; @return the default reconnection policy.", "code": "public static ReconnectionPolicy defaultReconnectionPolicy() {\n        return DEFAULT_RECONNECTION_POLICY;\n    }"}
{"description": "The default retry policy. <p> The default retry policy is {@link DefaultRetryPolicy}. @return the default retry policy.", "code": "public static RetryPolicy defaultRetryPolicy() {\n        return DEFAULT_RETRY_POLICY;\n    }"}
{"description": "The default address translater. <p> The default address tanslater is {@link IdentityTranslater}. @return the default address translater.", "code": "public static AddressTranslater defaultAddressTranslater() {\n        return DEFAULT_ADDRESS_TRANSLATER;\n    }"}
{"description": "The load balancing policy in use. <p> The load balancing policy defines how Cassandra hosts are picked for queries. @return the load balancing policy in use.", "code": "public LoadBalancingPolicy getLoadBalancingPolicy() {\n        return loadBalancingPolicy;\n    }"}
{"description": "The reconnection policy in use. <p> The reconnection policy defines how often the driver tries to reconnect to a dead node. @return the reconnection policy in use.", "code": "public ReconnectionPolicy getReconnectionPolicy() {\n        return reconnectionPolicy;\n    }"}
{"description": "The retry policy in use. <p> The retry policy defines in which conditions a query should be automatically retries by the driver. @return the retry policy in use.", "code": "public RetryPolicy getRetryPolicy() {\n        return retryPolicy;\n    }"}
{"description": "Checks if the item is available in the cache. @param requestUrl The url of the remote image @param maxWidth The maximum width of the returned image. @param maxHeight The maximum height of the returned image. @return True if the item exists in cache, false otherwise.", "code": "public boolean isCached(String requestUrl, int maxWidth, int maxHeight) {\n        throwIfNotOnMainThread();\n\n        String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight);\n        return mCache.getBitmap(cacheKey) != null;\n    }"}
{"description": "Returns an ImageContainer for the requested URL. The ImageContainer will contain either the specified default bitmap or the loaded bitmap. If the default was returned, the {@link com.android.volley.toolbox.ImageLoader} will be invoked when the request is fulfilled. @param requestUrl The URL of the image to be loaded. @param defaultImage Optional default image to return until the actual image is loaded.", "code": "public ImageContainer get(String requestUrl, final ImageListener listener) {\n        return get(requestUrl, listener, 0, 0);\n    }"}
{"description": "Sets the amount of time to wait after the first response arrives before delivering all responses. Batching can be disabled entirely by passing in 0. @param newBatchedResponseDelayMs The time in milliseconds to wait.", "code": "public void setBatchedResponseDelay(int newBatchedResponseDelayMs) {\n        mBatchResponseDelayMs = newBatchedResponseDelayMs;\n    }"}
{"description": "Returns the bitmap associated with the request URL if it has been loaded, null otherwise.", "code": "public Bitmap getBitmap() {\n            return mBitmap;\n        }"}
{"description": "Optionally specify the maximum number of rows that should be returns for the request. @param maxRows the maximum number of rows that the server should return from the request @return a Builder instance, not null", "code": "public Builder withMaxRows(final int maxRows) {\n      _maxRows = maxRows;\n      return this;\n    }"}
{"description": "Optionally specify a data transformation function for the request. @param transform the data transformation method that the server should pre-process the data with @return a Builder instance, not null", "code": "public Builder withTransform(final Transform transform) {\n      ArgumentChecker.notNull(transform, \"transform\");\n      _transform = transform;\n      return this;\n    }"}
{"description": "Optionally specify the sort order of the results. @param sortOrder the sort order of the results @return a Builder object onto which you can chain additional calls", "code": "public Builder withSortOrder(final SortOrder sortOrder) {\n      ArgumentChecker.notNull(sortOrder, \"sortOrder\");\n      _sortOrder = sortOrder;\n      return this;\n    }"}
{"description": "Write the vendor data to the ChannelBuffer @param data the channel buffer to which we're serializing", "code": "@Override\n    public void writeTo(final ChannelBuffer data) {\n        data.writeInt(this.dataType);\n    }"}
{"description": "Get the length of the vendor data. This implementation will normally be the superclass for another class that will override this to return the overall vendor data length. This implementation just returns the length of the part that includes the 4-byte integer data type value at the beginning of the vendor data.", "code": "@Override\n    public int getLength() {\n        return 4;\n    }"}
{"description": "Read the vendor data from the ChannelBuffer @param data the channel buffer from which we're deserializing @param length the length to the end of the enclosing message", "code": "@Override\n    public void readFrom(final ChannelBuffer data, final int length) {\n        this.dataType = data.readInt();\n    }"}
{"description": "Write the vendor data to the ChannelBuffer @param data the channel buffer to which we're serializing", "code": "@Override\n    public void writeTo(final ChannelBuffer data) {\n        data.writeInt(this.dataType);\n    }"}
{"description": "Provides means to compare if two cron expressions are equivalent. @param cronMapper - maps 'cron' parameter to this instance definition; @param cron - any cron instance, never null @return boolean - true if equivalent; false otherwise.", "code": "public boolean equivalent(CronMapper cronMapper, Cron cron){\n        return asString().equals(cronMapper.map(cron).asString());\n    }"}
{"description": "Provides means to compare if two cron expressions are equivalent. Assumes same cron definition. @param cron - any cron instance, never null @return boolean - true if equivalent; false otherwise.", "code": "public boolean equivalent(Cron cron){\n        return asString().equals(cron.asString());\n    }"}
{"description": "Sets how many milliseconds a call in {@link RiotApiAsync} waits for a response at most before timing out. This value can be set to zero to disable the request timeout. By default, the timeout value for asynchronous requests is 10 seconds. <p> To set the timeout for synchronous requests use {@link #setRequestTimeout(int)} instead. </p> @param timeout The maximum time for an asynchronous call to wait for a response until it times out @return This ApiConfig object for chaining @throws IllegalArgumentException If the timeout value is smaller than {@code 0}", "code": "public ApiConfig setAsyncRequestTimeout(int asyncRequestTimeout) {\r\n\t\tif (asyncRequestTimeout < 0) {\r\n\t\t\tthrow new IllegalArgumentException(\"The timeout value must be greater than or equal to 0\");\r\n\t\t}\r\n\t\tthis.asyncRequestTimeout = asyncRequestTimeout;\r\n\t\treturn this;\r\n\t}"}
{"description": "Sets whether the debug log should be saved in a file @param debugToFile {@code true} if the debug log should be saved in a file @return This ApiConfig object for chaining", "code": "public ApiConfig setDebugToFile(boolean debugToFile) {\r\n\t\tthis.debugToFile = debugToFile;\r\n\t\treturn this;\r\n\t}"}
{"description": "Sets whether the api should attempt to automatically respect rate limits. If set to {@code true}, the api will listen to rate-limit-specific headers from the Riot Api and try to respect them. @param respectRateLimit {@code true} if the api should attempt to automatically respect rate limits @return This ApiConfig object for chaining", "code": "public ApiConfig setRespectRateLimit(boolean respectRateLimit) {\r\n\t\tthis.respectRateLimit = respectRateLimit;\r\n\t\treturn this;\r\n\t}"}
{"description": "Returns <tt>true</tt> if this task was cancelled before it completed normally. If you are calling {@link #cancel(boolean)} on the task, the value returned by this method should be checked periodically from {@link #doInBackground(Object[])} to end the task as soon as possible. @return <tt>true</tt> if task was cancelled before it completed @see #cancel(boolean)", "code": "public final boolean isCancelled() {\n        return mCancelled.get();\n    }"}
{"description": "Waits if necessary for the computation to complete, and then retrieves its result. @return The computed result. @throws java.util.concurrent.CancellationException If the computation was cancelled. @throws java.util.concurrent.ExecutionException If the computation threw an exception. @throws InterruptedException If the current thread was interrupted while waiting.", "code": "public final Result get() throws InterruptedException, ExecutionException {\n        return mFuture.get();\n    }"}
{"description": "Waits if necessary for at most the given time for the computation to complete, and then retrieves its result. @param timeout Time to wait before cancelling the operation. @param unit The time unit for the timeout. @return The computed result. @throws java.util.concurrent.CancellationException If the computation was cancelled. @throws java.util.concurrent.ExecutionException If the computation threw an exception. @throws InterruptedException If the current thread was interrupted while waiting. @throws java.util.concurrent.TimeoutException If the wait timed out.", "code": "public final Result get(long timeout, TimeUnit unit) throws InterruptedException,\n            ExecutionException, TimeoutException {\n        return mFuture.get(timeout, unit);\n    }"}
{"description": "Executes the task with the specified parameters. The task returns itself (this) so that the caller can keep a reference to it. <p>Note: this function schedules the task on a queue for a single background thread or pool of threads depending on the platform version. When first introduced, AsyncTasks were executed serially on a single background thread. Starting with {@link android.os.Build.VERSION_CODES#DONUT}, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting {@link android.os.Build.VERSION_CODES#HONEYCOMB}, tasks are back to being executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can use the {@link #executeOnExecutor} version of this method with {@link #THREAD_POOL_EXECUTOR}; however, see commentary there for warnings on its use. <p>This method must be invoked on the UI thread. @param params The parameters of the task. @return This instance of AsyncTask. @throws IllegalStateException If {@link #getStatus()} returns either {@link net.bither.image.cache.AsyncTask.Status#RUNNING} or {@link net.bither.image.cache.AsyncTask.Status#FINISHED}. @see #executeOnExecutor(java.util.concurrent.Executor, Object[]) @see #execute(Runnable)", "code": "public final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n    }"}
{"description": "Convenience version of {@link #execute(Object...)} for use with a simple Runnable object. See {@link #execute(Object[])} for more information on the order of execution. @see #execute(Object[]) @see #executeOnExecutor(java.util.concurrent.Executor, Object[])", "code": "public static void execute(Runnable runnable) {\n        sDefaultExecutor.execute(runnable);\n    }"}
{"description": "Add a new option to the list of options we accept @param option the new option @return ourselves so that you may chain the calls", "code": "public Getopt addOption(CommandLineOption option) {\n        options.add(option);\n        return this;\n    }"}
{"description": "Get the index of the first non-argument option. @return The position in the argument vector for the first non-argument option", "code": "public int getOptind() {\n        return optind;\n    }"}
{"description": "Convert the argument to a <code>Boolean</code> @param context the context at the point in the expression when the function is called @param args a list with exactly one item which will be converted to a <code>Boolean</code> @return the result of evaluating the function; <code>Boolean.TRUE</code> or <code>Boolean.FALSE</code> @throws FunctionCallException if <code>args</code> has more or less than one item", "code": "public Object call(Context context,\n                       List args) throws FunctionCallException\n    {\n        if ( args.size() == 1 )\n        {\n            return evaluate( args.get(0), context.getNavigator() );\n        }\n\n        throw new FunctionCallException(\"boolean() requires one argument\");\n    }"}
{"description": "Set if ripple animation has to be centered in its parent view or not, default is False @param isCentered", "code": "public void setCentered(final Boolean isCentered)\n    {\n        this.isCentered = isCentered;\n    }"}
{"description": "Sets the default package that will be searched for classes to construct for tag names that have no explicit package. @param defaultPackage The default package. This will be prepended to the tag name, so it should end with a period.", "code": "public void setDefaultPackage(String defaultPackage) {\n        mDefaultPackage = defaultPackage;\n    }"}
{"description": "Returns the default package, or null if it is not set. @see #setDefaultPackage(String) @return The default package.", "code": "public String getDefaultPackage() {\n        return mDefaultPackage;\n    }"}
{"description": "Return the current factory (or null). This is called on each element name. If the factory returns an item, add that to the hierarchy. If it returns null, proceed to call onCreateItem(name).", "code": "public final Factory<T> getFactory() {\n        return mFactory;\n    }"}
{"description": "This routine is responsible for creating the correct subclass of item given the xml element name. Override it to handle custom item objects. If you override this in your subclass be sure to call through to super.onCreateItem(name) for names you do not recognize. @param name The fully qualified class name of the item to be create. @param attrs An AttributeSet of attributes to apply to the item. @return The item created.", "code": "protected T onCreateItem(String name, AttributeSet attrs) throws ClassNotFoundException {\n        return createItem(name, mDefaultPackage, attrs);\n    }"}
{"description": "Gets a template with the specified template directory name and template name. @param templateDirName the specified template directory name @param templateName the specified template name @return template", "code": "protected Template getTemplate(final String templateDirName, final String templateName) {\r\n        return Templates.getTemplate(templateDirName, templateName);\r\n    }"}
{"description": "Insert a row into the specified {@code table} and notify any subscribed queries. @see SQLiteDatabase#insert(String, String, ContentValues) TODO @WorkerThread", "code": "public long insert(@NonNull String table, @NonNull ContentValues values) {\n    return insert(table, values, CONFLICT_NONE);\n  }"}
{"description": "An id for the series. This can be used after render time to get a pointer to the series object through chart.get(). @param id the id to set @return", "code": "public Series setId(String id) {\r\n        this.id = id;\r\n        return this;\r\n    }"}
{"description": "The name of the series as shown in the legend, tooltip etc. @param name the name to set @return", "code": "public Series setName(String name) {\r\n        this.name = name;\r\n        return this;\r\n    }"}
{"description": "Reads the named file, translating {@link IOException} to a {@link RuntimeException} of some sort. @param fileName {@code non-null;} name of the file to read @return {@code non-null;} contents of the file", "code": "public static byte[] readFile(String fileName) {\n        File file = new File(fileName);\n        return readFile(file);\n    }"}
{"description": "Returns an KBStatus enum which describes whether <code>nameOrId</code> exists in the KB and is an instance of <code>#$Individual</code>. @param nameOrId either the name or HL ID of an entity in the KB @return an enum describing the existential status of the entity in the KB", "code": "public static KbStatus getStatus(String nameOrId)  {\n    return KbObjectFactory.getStatus(nameOrId, QuantifierImpl.class);\n\n  }"}
