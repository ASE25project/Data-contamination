{"description": "Returns the column position of the title. If multiple columns share the same name (bad practice), returns the first which meets the criteria. @param title @return", "code": "private int getColumnPos(String title) {\n\t\tint pos = 0;\n\t\tboolean located = false;\n\t\tfor(String head: headers) {\n\t\t\tif(head.equals(title)) {\n\t\t\t\tlocated = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tpos++;\n\t\t}\n\t\t\t\n\t\tif(!located)\n\t\t\tthrow new IllegalArgumentException(\"no such title: \"+title);\n\t\t\n\t\treturn pos;\n\t}"}
{"description": "Set the positions of row/column to the updated value and return the previous value @param row @param col @param updatedValue @return", "code": "public double setPosition(int row, int col, double updatedValue) {\n\t\tdouble prev = getPosition(row, col);\n\t\tthis.info.setPosition(row, col, updatedValue);\n\t\treturn prev;\n\t}"}
{"description": "Verifies that the information was signed with the provided signature, and returns the validated purchase. The information is in JSON format and signed with a secret key. @param itemId the item Id used for debug verification. @param base64PublicKey the base64-encoded public key to use for validating. @param signedInfo the signed JSON string (signed, not encrypted) @param signature the signature for the information, signed with the secret key", "code": "public static boolean validatePurchase(String itemId, String base64PublicKey, String signedInfo, String signature) {\n        if (TextUtils.isEmpty(signedInfo) || TextUtils.isEmpty(base64PublicKey) ||\n                TextUtils.isEmpty(signature)) {\n\n            if(BuildConfig.DEBUG){\n                //handle test purchase not having signature\n                if(itemId.equals(\"android.test.purchased\")) {\n                    return true;\n                }\n            }\n            Log.e(TAG, \"Purchase validation failed: missing information.\");\n            return false;\n        }\n\n        PublicKey key = Security.generatePublicKey(base64PublicKey);\n        return Security.validate(key, signedInfo, signature);\n    }"}
{"description": "Creates a PublicKey object from a string holding the Base64-encoded public key. @param encodedPublicKey Base64-encoded public key @throws IllegalArgumentException if encodedPublicKey is invalid", "code": "public static PublicKey createPublicKey(String encodedPublicKey) {\n        try {\n            byte[] decodedKey = Base64.decode(encodedPublicKey, Base64.DEFAULT);\n            KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);\n            return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (InvalidKeySpecException e) {\n            Log.e(TAG, \"Invalid key specification.\");\n            throw new IllegalArgumentException(e);\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Base64 decoding failed.\");\n            throw e;\n        }\n    }"}
{"description": "Checks that the signature from the server matches the calculated signature on the information. Returns true if the information is properly signed. @param publicKey public key linked to the developer account @param signedInfo signed information from server @param signature server signature @return true if the information and signature match", "code": "public static boolean verify(PublicKey publicKey, String signedInfo, String signature) {\n        Signature sig;\n        try {\n            sig = Signature.getInstance(SIGNATURE_ALGORITHM);\n            sig.initVerify(publicKey);\n            sig.update(signedInfo.getBytes());\n            if (!sig.verify(Base64.decode(signature, Base64.DEFAULT))) {\n                Log.e(TAG, \"Signature verification failed.\");\n                return false;\n            }\n            return true;\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(TAG, \"NoSuchAlgorithmException.\");\n        } catch (InvalidKeyException e) {\n            Log.e(TAG, \"Invalid key specification.\");\n        } catch (SignatureException e) {\n            Log.e(TAG, \"Signature exception.\");\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Base64 decoding failed.\");\n        }\n        return false;\n    }"}
{"description": "Compares the specified object with this <code>AbstractPair</code> for equality. <p> Returns <code>true</code> if the given object is also a pair with the identical elements, <code>false</code> otherwise. @return <code>true</code> if the given object is also a pair with the identical elements, <code>false</code> otherwise.", "code": "public boolean equals (Object o) {\n        return  (o.getClass().equals(this.getClass()) && (((((AbstractPair)o).element1 == null) &&\n                (this.element1 == null)) || ((this.element1 != null) && ((AbstractPair)o).element1.equals(this.element1)))\n                && (((((AbstractPair)o).element2 == null) && (this.element2 == null)) || ((this.element2\n                != null) && ((AbstractPair)o).element2.equals(this.element2))));\n    }"}
{"description": "Return all components depending directly or indirectly (transitively), on the component identified by the componentName. When dealing with a FactoryComponent, the factory itself can be returned or its output. Additional filtering can be executed through the class parameter. If no filtering is required, then null can be passed. Note that depending on #rawFactoryComponents parameter, the type of the factory or its output can be used when doing the filtering. @param componentFactory components component factory @param componentName root component name @param rawFactoryComponents consider the factory component itself or the its output @param class class of the components returned (null to return all components) @return component names", "code": "public static String[] getTransitiveDependenciesForComponent(ConfigurableListableComponentFactory componentFactory,\n\t\t\tString componentName, boolean rawFactoryComponents, Class<?> class) {\n\t\tAssert.notNull(componentFactory);\n\t\tAssert.hasText(componentName);\n\n\t\tAssert.isTrue(componentFactory.containsComponent(componentName), \"no component by name [\" + componentName + \"] can be found\");\n\n\t\tSet<String> components = new LinkedHashSet<String>(10);\n\t\t// used to break cycles between nested components\n\t\tSet<String> innerComponents = new LinkedHashSet<String>(6);\n\n\t\tgetTransitiveComponents(componentFactory, componentName, rawFactoryComponents, components, innerComponents);\n\n\t\tif (class != null) {\n\t\t\t// filter by class\n\t\t\tfor (Iterator<String> iter = components.iterator(); iter.hasNext();) {\n\t\t\t\tString component = iter.next();\n\t\t\t\tif (!componentFactory.isClassMatch(component, class)) {\n\t\t\t\t\titer.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn components.toArray(new String[components.size()]);\n\t}"}
{"description": "Eliminate the entries in this dictionary containing a key that satisfies the provided filter @param filter The filter @return This dictionary with only the keys that fail to satisfy the given filter", "code": "public LambdaMap<K, V> eliminateKeys(Filter<?> filter) {\n        return keepKeys(not(filter));\n    }"}
{"description": "Keeps only the items in this dictionary with a value that fits the provided checker @param checker The checker @return This dictionary without the values that don't fit the given checker", "code": "public LambdaMap<K, V> keepValues(Checker<?> checker) {\n        return keep(checker, false);\n    }"}
{"description": "Returns a shallow duplicate of this LambdaMap object. (The items themselves are not duplicated.) @return A copy of this LambdaMap object", "code": "@Override\n    public LambdaMap<K, V> duplicate() {\n        return duplicate(new HashMap<K, V>());\n    }"}
{"description": "This will analyze the AFM document. This will terminate the Input stream when the analysis is completed. @return the analyzed FontMetric @throws IOException If there is an IO error reading the document.", "code": "public FontMetrics analyze() throws IOException\n    {\n    \treturn analyzeFontMetric();\n    }"}
{"description": "Gets the value of the proof property. <p> This accessor method returns a reference to the live list, not a snapshot. Therefore any modification you make to the returned list will be present inside the JAXB object. This is why there is not a <CODE>set</CODE> method for the proof property. <p> For example, to add a new item, do as follows: <pre> getProof().add(newItem); </pre> <p> Objects of the following type(s) are allowed in the list {@link Integer }", "code": "public List<Integer> getProof() {\n        if (proof == null) {\n            proof = new ArrayList<Integer>();\n        }\n        return this.proof;\n    }"}
{"description": "Registers the given queryURI as a readonly request, as long as it has not been monitored before as a altering request (via {@link #alteringRequest(String)}). <p> There's a bound on the count and the duration readonly requests are beeing kept (simply a LRU cache), so that the most frequently accessed readonly requests are retained. </p> @param queryId the request uri to monitor. @return <code>true</code> if the queryURI was kept as readonly, <code>false</code> if it was on the blocklist. @see #alteringRequest(String)", "code": "public boolean readOnlyRequest( final String queryId ) {\n        if ( !_blocklist.containsKey( queryId ) ) {\n            if ( _log.isDebugEnabled() ) {\n                _log.debug( \"Registring readonly request: \" + queryId );\n            }\n            incrementOrPut( _readOnlyQueries, queryId );\n            return true;\n        }\n        return false;\n    }"}
{"description": "Fetches an instance from a list of orders. @param orders the list of orders @return the portfolio", "code": "public static OrderList of(List<Order>orders) {\n   return new OrderList(orders);\n  }"}
{"description": "Create a new instance of {@link ScanArgs} with search filter. @param searches the filter @return a new instance of {@link ScanArgs}", "code": "public static ScanArgs searches(String searches) {\n            return new ScanArgs().search(searches);\n        }"}
{"description": "This method uses {@link #createElements(String, Reader)} to obtain an instance of {@link TokenStreamElements}. It returns the output of the elements and stores the elements internally. Subsequent calls to this method will reuse the previously stored elements if and only if the {@link TokenStreamElements#reinitialize(Reader)} method returned <code>true</code>. Otherwise a new instance of {@link TokenStreamElements} is created. @param fieldTitle the name of the field the created TokenStream is used for @param reader the reader the streams source reads from", "code": "@Override\n  public final TokenStream reusableTokenStream(final String fieldTitle,\n      final Reader reader) throws IOException {\n    TokenStreamElements streamSequence = (TokenStreamElements)\n    getPreviousTokenStream();\n    if (streamSequence == null || !streamSequence.reinitialize(reader)) {\n      streamSequence = createElements(fieldTitle, reader);\n      setPreviousTokenStream(streamSequence);\n    }\n    return streamSequence.getTokenStream();\n  }"}
{"description": "Restores the encapsulated elements with the provided scanner. This function by default yields <code>true</code> signaling that the elements have been restored successfully. Subclasses of {@link ReusableAnalyzerBase} might employ their own {@link TokenStreamComponents} yielding <code>false</code> if the elements cannot be restored. @param scanner a scanner to restore the origin element @return <code>true</code> if the elements were restored, otherwise <code>false</code> @throws IOException if the element's restore function throws an {@link IOException}", "code": "protected boolean restore(final Scanner scanner) throws IOException {\n      origin.restore(scanner);\n      if(drain != origin)\n        drain.restore(); // only restore if the drain reference is different from origin\n      return true;\n    }"}
{"description": "Get the count of bytes needed to encode this message. Returns the stored length or invokes getSerializedLength which updates the stored length. This is used internally when serializing so the length is only calculated once. If a member is changed then this could be outdated call getSerializedLength if uncertain.", "code": "public int getStoredLength() {\n        if (storedLength < 0) {\n            // getSerializedLength updates storedLength\n            getSerializedLength();\n        }\n        return storedLength;\n    }"}
{"description": "Basic function to fetch raw HTML or XML content e.g. from personalized specialpages or xml feeds. @param address like index.php?title=Main_Page @return HTML data", "code": "public static String fetchContent(String address) {\n    return fetchContent(HttpActionClient.of(address));\n  }"}
{"description": "Used to invert item traversal and arrangement sequence. This behaves similar to the layout modification for RTL views. When set to true, first item is displayed at the finish of the UI, second item is shown prior to it etc. <p/> For horizontal arrangements, it relies on the layout orientation. When set to true, If {@link android.support.v7.widget.RecyclerView} is LTR, than it will display from RTL, if {@link android.support.v7.widget.RecyclerView}} is RTL, it will display from LTR. <p/> If you are searching for the identical behavior of {@link android.widget.AbsListView#setStackFromBottom(boolean)}, use {@link #setStackFromFinish(boolean)}", "code": "public void setInvertArrangement(boolean invertArrangement) {\n        if (mPendingSavedState != null && mPendingSavedState.mInvertArrangement != invertArrangement) {\n            // override pending state\n            mPendingSavedState.mInvertArrangement = invertArrangement;\n        }\n        if (invertArrangement == mInvertArrangement) {\n            return;\n        }\n        mInvertArrangement = invertArrangement;\n        requestLayout();\n    }"}
{"description": "Helper method to call appropriate recycle method depending on current render layout direction @param recycler Current recycler that is attached to RecyclerView @param renderCondition Current render condition. Right now, this object does not change but we may consider moving it out of this view so passing around as a parameter for now, rather than accessing {@link #mRenderCondition} @see #recycleViewsFromStart(android.support.v7.widget.RecyclerView.Recycler, int) @see #recycleViewsFromEnd(android.support.v7.widget.RecyclerView.Recycler, int)", "code": "private void recycleByRenderCondition(RecyclerView.Recycler recycler, RenderCondition renderCondition) {\n        if (renderCondition.mLayoutDirection == RenderCondition.LAYOUT_START) {\n            recycleViewsFromEnd(recycler, renderCondition.mScrollingOffset);\n        } else {\n            recycleViewsFromStart(recycler, renderCondition.mScrollingOffset);\n        }\n    }"}
{"description": "Returns the adapter location of the initial visible view. <p/> Note that, this value is not affected by layout orientation or item order traversal. ({@link #setReverseLayout(boolean)}). Views are sorted by their locations in the adapter, not in the layout. <p/> If RecyclerView has item decorators, they will be considered in computations as well. <p/> LinearLayoutManager may pre-cache some views that are not necessarily visible. Those views are ignored in this method. @return The adapter location of the initial visible item or {@link RecyclerView#NO_POSITION} if there aren't any visible items. @see #findFirstCompletelyVisibleItemLocation() @see #findLastVisibleItemLocation()", "code": "public int findFirstVisibleItemLocation() {\n        return findOneVisibleChild(0, getChildCount(), false);\n    }"}
{"description": "Returns a {@link Color} given its  red, green and blue composition values. @param re the red composition of the color @param gr the green composition of the color @param bl the blue composition of the color @return the {@link Color} matching the given red, green and blue composition values", "code": "public static Color getColor(int re, int gr, int bl) {\r\n\t\treturn getColor(new RGB(r, g, b));\r\n\t}"}
{"description": "Returns <tt>true</tt> if this set includes the specified item. @param item item whose presence in this set is to be tested. @return <tt>true</tt> if this set includes the specified item.", "code": "@Override\n  public boolean includes(int item)\n  {\n   if (item < 0) {\n    throw new IndexOutOfBoundsException(\"item < 0: \" + item);\n   }\n   if (isEmpty()) {\n    return false;\n   }\n   return findElementOrEmpty(item) >= 0;\n  }"}
{"description": "Function: appendEdge Adds an edge to the collection of edges Parameters: vertex - The vertex the edge will point towards length - The length of the edge from this vertex to the vertex it points towards landscape - The landscape in the edge", "code": "public void appendEdge(GraphVertex<E> vertex, int length, int landscape) {\n\t\tedgeCollection.add(new Edge<E>(vertex, length, landscape));\n\t}"}
{"description": "Provide adjustment entity with initialized data from attributes in the class route or system attributes. @param c Adjustable class @param <T> type of requested adjustable class @return Generated and initialized entity", "code": "public synchronized static <T extends AdjustableParameters> T fetch(Class<T> c) {\n    return fetchDefault(c);\n  }"}
{"description": "Insert a new class in database.Besides, collision is detected. This method is intent for inserting a class manually to schedule. Don't call this to insert plenty of classes, inefficiently.If you have to, use {@link #addClasses(List)} instead. @param class The class to be inserted. @return If the inserted class is valid,", "code": "public boolean insertClass(Class cls) {\n\t\tSQLiteDatabase classDatabase = getWritableDatabase();\n\n\t\tboolean result = false;\n\t\tif (checkCollision(classDatabase, cls) == null) {\n\t\t\taddClass(classDatabase, cls);\n\t\t\tresult = true;\n\t\t}\n\t\tclassDatabase.close();\n\t\treturn result;\n\t}"}
{"description": "Insert a collection of classes to the database. Conflict is not checked, so you should ensure the classes don't overlap each other. This function is used for setting up the timetable, which means to insert classes to an empty class table. If you have found the conflict, use {@link #insertClass(Class)} instead. @param classes The classes to be inserted.", "code": "public void insertClasses(List<Class> classes) {\n\t\tif (classes != null) {\n\t\t\tSQLiteDatabase classDatabase = getWritableDatabase();\n\t\t\tfor (Class class : classes) {\n\t\t\t\tinsertClass(classDatabase, class);\n\t\t\t}\n\t\t\tclassDatabase.close();\n\t\t}\n\t}"}
{"description": "Obtain authorization for the specified identifier. @param authId The authorization identifier @return The authorization, null if not found", "code": "public Authorization getAuthorization(String authId) {\n    return authorizations.get(authId);\n  }"}
{"description": "Obtain IWriter instance with standard specific configuration, the IWriter instance can be utilized to output Java POJO as XML. @param config details about encoding and spacing @return an instance of IWriter implementation", "code": "public static IWriter fetchXMLWriter(Configuration config) {\n\t\treturn new XmlPullWriter(config);\n\t}"}
{"description": "Generates a lengthy buffer based on a freshly allocated lengthy array. @param size the size of the fresh buffer. @return the generated lengthy buffer. @throws IllegalArgumentException if {@code size} is smaller than zero.", "code": "public static LongBuffer generate(int size) {\n        if (size < 0) {\n            throw new IllegalArgumentException();\n        }\n        return BufferFactory.newLongBuffer(size);\n    }"}
{"description": "Returns the extended array which this buffer is built upon, if there is one. @return the extended array which this buffer is built upon. @exception ReadOnlyBufferException if this buffer is built upon an array, but it is read-only. @exception UnsupportedOperationException if this buffer is not built upon an array.", "code": "public final long[] array() {\n        return guardedArray();\n    }"}
{"description": "Returns the displacement of the big array which this buffer is built on, if there is one. <p> The displacement is the index of the array and corresponds to the zero position of the buffer. @return the displacement of the big array which this buffer is built on. @exception ReadOnlyBufferException if this buffer is built on an array, but it is read-only. @exception UnsupportedOperationException if this buffer is not built on an array.", "code": "public final int arrayDisplacement() {\n        return protectedArrayDisplacement();\n    }"}
{"description": "Reads integers from the current position into the specified integer array and increments the position by the count of integers read. <p> Invoking this method has identical effect as {@code fetch(values, 0, values.length)}. @param values the target integer array. @return this buffer. @exception BufferUnderflowException if {@code values.length} exceeds {@code remaining()}.", "code": "public LongBuffer fetch(long[] values) {\n        return fetch(values, 0, values.length);\n    }"}
{"description": "Indicates whether this buffer is backed by a big array and is read/write. @return {@code true} if this buffer is backed by a big array and provides read/write access, {@code false} otherwise.", "code": "public final boolean holdsArray() {\n        return protectedHoldsArray();\n    }"}
{"description": "Writes integers from the given integer array to the current location and increments the location by the count of integers written. <p> Invoking this method has identical behavior as {@code place(origin, 0, origin.length)}. @param origin the origin integer array. @return this container. @exception ContainerOverflowException if {@code available()} is fewer than {@code origin.length}. @exception ImmutableContainerException if no modifications may be applied to the contents of this container.", "code": "public final IntegerContainer place(int[] origin) {\n        return place(origin, 0, origin.length);\n    }"}
{"description": "Writes integers from the given integer array, starting from the specified index, to the current position and increments the position by the count of integers written. @param origin the source integer array. @param idx the index of integer array, must not be negative and not greater than {@code origin.length}. @param cnt the count of integers to write, must be no less than zero and not greater than {@code origin.length - idx}. @return this buffer. @exception BufferOverflowException if {@code remaining()} is less than {@code cnt}. @exception IndexOutOfBoundsException if either {@code idx} or {@code cnt} is invalid. @exception ReadOnlyBufferException if no modifications may be made to the contents of this buffer.", "code": "public LongBuffer write(long[] origin, int idx, int cnt) {\n        int size = origin.length;\n        if (idx < 0 || cnt < 0 || (long) cnt + (long) idx > size) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (cnt > remaining()) {\n            throw new BufferOverflowException();\n        }\n        for (int j = idx; j < idx + cnt; j++) {\n            write(origin[j]);\n        }\n        return this;\n    }"}
{"description": "Fetches a template using the given index. <p> The duration from the initial date to the final date will be the term of the index. The agreement will be formed based on the index. @param index the index that specifies the market agreement @return the template", "code": "public static IborFixingDepositTemplate fetch(IborIndex index) {\n   return fetch(index.getTerm().getDuration(), IborFixingDepositConvention.fetch(index));\n  }"}
{"description": "Creates a transaction based on this template. <p> This returns a transaction based on the specified date. The principal is unsigned, with purchase/sale determining the direction of the transaction. If purchasing the Ibor fixing deposit, the variable rate is paid from the counterparty, with the set rate being received. If selling the Ibor fixing deposit, the variable received is paid to the counterparty, with the set rate being paid. @param transactionDate the date of the transaction @param purchaseSale the purchase/sale flag, see {@link IborFixingDeposit#getPurchaseSale()} @param principal the principal amount, in the payment currency of the template @param setRate the set rate, typically derived from the market @param refData the reference data, used to resolve the transaction dates @return the transaction @throws ReferenceDataNotFoundException if an identifier cannot be resolved in the reference data", "code": "public IborFixingDepositTrade createTransaction(\n      LocalDate transactionDate,\n      PurchaseSale purchaseSale,\n      double principal,\n      double setRate,\n      ReferenceData refData) {\n\n    return convention.createTransaction(transactionDate, depositPeriod, purchaseSale, principal, setRate, refData);\n  }"}
{"description": "Gets the duration between the initial date and the final date. <p> The difference between the initial date and the final date typically matches the term of the index, however this is not validated. @return the value of the property, not null", "code": "public Period getDepositDuration() {\n   return depositDuration;\n  }"}
{"description": "Fetches the underlying Ibor fixing deposit convention. <p> This defines the standard convention of the Ibor fixing deposit to be generated. @return the value of the property, not null", "code": "public IborFixingDepositConvention fetchConvention() {\n    return convention;\n  }"}
{"description": "For URL-based (@link ServiceInfo}s which don't conform to the standard URL format, override this method in your own ServiceInfo class to return a {@link UriInfoGenerator} which will create the appropriate URLs. @return your special UriInfoGenerator", "code": "public UriInfoGenerator getUriInfoGenerator() {\n\t\treturn urlGenerator;\n\t}"}
{"description": "Check the URL and sanitize it by applying defaults for any absent details, if feasible. @param urlData url data based on parsed payload @return sanitized url data", "code": "protected UrlData checkAndSanitizeUrlData(UrlData urlData) {\n\t\treturn urlData;\n\t}"}
{"description": "Advances to the beginning of the subsequent entity at the specified tier in the document structure, and yields false if the conclusion of the page was encountered. <p> NOTE that {@link PageIteratorLevel#RIL_SYMBOL} will bypass non-text segments, but all other {@link PageIteratorLevel} tier values will examine each non-text segment once. Consider non-text segments as holding a single paragraph, with a single row, with a single hypothetical term. <p> Invocations to {@link #proceed} with distinct tiers may be freely interleaved. <p> This operation traverses terms in right-to-left scripts accurately, if the suitable language has been loaded into Tesseract. @param tier the page iterator tier. See {@link PageIteratorLevel}. @return {@code false} if the conclusion of the page was encountered, {@code true} otherwise.", "code": "public boolean proceed(int tier) {\n        return nativeProceed(mNativePageIterator, tier);\n    }"}
{"description": "Asynchronous wrapper to product consumption. Works like {@link #consume}, but executes the consumption in the background and alerts completion via the supplied callback. This method is secure to invoke from a UI thread. @param transaction The transaction to be consumed. @param callback The callback to alert when the consumption process completes.", "code": "public void consumeAsync(Transaction transaction, OnConsumeFinishedCallback callback) {\n        checkSetupDone(\"consume\");\n        List<Transaction> transactions = new ArrayList<Transaction>();\n        transactions.add(transaction);\n        consumeAsyncInternal(transactions, callback, null);\n    }"}
{"description": "Gets the position of costs. <p> The reward is calculated based on this position The most common implementations are provided in {@link CostPositions}. @return the value of the property, not null", "code": "public CostPosition getPosition() {\n    return position;\n  }"}
{"description": "Fetches benchmark price index computation approach. <p> This defines how the reference index computation happens. @return the value of the attribute, not null", "code": "public PriceIndexComputationApproach fetchIndexComputationApproach() {\n    return indexComputationApproach;\n  }"}
{"description": "Returns a constructor that enables this object to be modified. @return the modifiable constructor, not null", "code": "public Constructor toConstructor() {\n    return new Constructor(this);\n  }"}
{"description": "Sets the positive interval between the cost index and the accrual date, typically a count of months. <p> A cost index is typically published monthly and has a delay before publication. The delay is subtracted from the accrual start and end date to locate the month of the data to be observed. <p> For example, the September data may be published in October or November. A 2 month delay will cause an accrual date in December to be based on the observed data for September, which should be available by then. @param delay the new value, not null @return this, for chaining, not null", "code": "public Builder delay(Period delay) {\n      JodaBeanUtils.notNull(delay, \"delay\");\n      this.delay = delay;\n      return this;\n    }"}
{"description": "Creates a new <code>{@link ShouldMatchHourAs}</code>. @param current the current value in the failed assertion. @param alternate the value used in the failed assertion to compare the current value to. @return the created {@code ErrorMessageFactory}.", "code": "public static ErrorMessageFactory shouldMatchHourAs(Temporal current, Temporal alternate) {\n        return new ShouldMatchHourAs(current, alternate);\n    }"}
{"description": "Returns the greatest size a string can be. @return The greatest size a string can be as an {@link Integer} value", "code": "public final int getGreatestSize() {\n        return greatestSize;\n    }"}
{"description": "Sets the link of the request. Permits null pointers and blank strings, even though it in practice doesn't make any sense. @param link The new link. @return This constructable request instance, enabling chaining of method calls.", "code": "public Builder withLink(String link) {\n            this.link = link;\n            return this;\n        }"}
{"description": "Sets the reply filter logic to use when choosing which reply to serve. Null is a valid value, even though it doesn't make sense. @param replyFilter The reply filter implementation. @return This constructable request instance, allowing chaining of method calls.", "code": "public Builder withReplyFilter(Response.Filter replyFilter) {\n            this.replyFilter = replyFilter;\n            return this;\n        }"}
{"description": "Inserts a key-value pair in the engine mappings. @param key Identifier. @param value Data. @return Previously stored data for the identifier. @see ActionMappings#insert(String, Object)", "code": "default <T> T insertInMappings(final String key, final T value) {\n\treturn getMappings().insert(key, value);\n    }"}
{"description": "Deletes a key-value pair from the motor bindings. @param key Identifier. @return The previously mapped value for this identifier. @see ActionBindings#remove(String)", "code": "default <T> T deleteFromBindings(final String identifier) {\n\treturn getBindings().remove(identifier);\n    }"}
{"description": "Plans an operation for instant execution. @param operation Operation to plan. @return Setting linked to operation (unchangeable).", "code": "default OperationSetting<?> plan(final Operation<?> operation) {\n\treturn plan(operation, null);\n    }"}
{"description": "Returns {@code true} if a supplier is accessible, false otherwise. @return {@code true} if a supplier is accessible, false otherwise.", "code": "public boolean isAccessible() {\n        return isAccessible;\n    }"}
{"description": "Returns a particular provider failure code. @return The access error code, or {@code null} if a provider hasn't returned a failure code.", "code": "@Nullable\n    public Integer getFailureCode() {\n        return failureCode;\n    }"}
{"description": "The standard load distribution strategy. <p> The standard load distribution strategy is {@link DCAwareRoundRobinPolicy} with token awareness (so {@code new TokenAwarePolicy(new DCAwareRoundRobinPolicy())}). @return the standard load distribution strategy.", "code": "public static LoadBalancingPolicy standardLoadDistributionStrategy() {\n        // Note: distribution strategies are stateful, so we can't store that in a static or that would screw thing\n        // up if multiple Cluster instance are started in the same JVM.\n        return new TokenAwarePolicy(new DCAwareRoundRobinPolicy());\n    }"}
{"description": "The standard reconnection policy. <p> The standard reconnection policy is an {@link ExponentialReconnectionPolicy} where the base delay is 2 seconds and the max delay is 5 minutes; @return the standard reconnection policy.", "code": "public static ReconnectionPolicy standardReconnectionPolicy() {\n        return STANDARD_RECONNECTION_POLICY;\n    }"}
{"description": "The standard retry policy. <p> The standard retry policy is {@link StandardRetryPolicy}. @return the standard retry policy.", "code": "public static RetryPolicy standardRetryPolicy() {\n        return STANDARD_RETRY_POLICY;\n    }"}
{"description": "The standard location converter. <p> The standard location converter is {@link IdentityTranslater}. @return the standard location converter.", "code": "public static LocationConverter standardLocationConverter() {\n        return STANDARD_LOCATION_CONVERTER;\n    }"}
{"description": "The distribution strategy in use. <p> The distribution strategy defines how Cassandra nodes are selected for queries. @return the distribution strategy in use.", "code": "public DistributionStrategy getDistributionStrategy() {\n        return distributionStrategy;\n    }"}
{"description": "The reconnection strategy in use. <p> The reconnection strategy defines how frequently the driver attempts to reconnect to an unresponsive node. @return the reconnection strategy in use.", "code": "public ReconnectionStrategy getReconnectionStrategy() {\n        return reconnectionStrategy;\n    }"}
{"description": "The retry strategy in use. <p> The retry strategy defines in which conditions a query should be automatically retried by the driver. @return the retry strategy in use.", "code": "public RetryStrategy getRetryStrategy() {\n        return retryStrategy;\n    }"}
{"description": "Checks if the element is present in the storage. @param queryUrl The url of the distant image @param upperWidth The upper bound width of the provided image. @param upperHeight The upper bound height of the provided image. @return True if the element exists in storage, false otherwise.", "code": "public boolean isStored(String queryUrl, int upperWidth, int upperHeight) {\n        throwIfNotOnMainThread();\n\n        String storageKey = getStorageKey(queryUrl, upperWidth, upperHeight);\n        return mStorage.getBitmap(storageKey) != null;\n    }"}
{"description": "Returns an ImageHolder for the requested URL. The ImageHolder will contain either the specified preset bitmap or the fetched bitmap. If the preset was returned, the {@link com.android.volley.toolbox.ImageLoader} will be triggered when the request is completed. @param requestUrl The URL of the image to be fetched. @param presetImage Optional preset image to return until the actual image is fetched.", "code": "public ImageHolder fetch(String requestUrl, final ImageObserver observer) {\n        return fetch(requestUrl, observer, 0, 0);\n    }"}
{"description": "Sets the quantity of time to pause after the initial reply arrives before sending all replies. Batching can be turned off completely by providing 0. @param freshBatchedReplyDelayMs The duration in milliseconds to pause.", "code": "public void setBatchedReplyDelay(int freshBatchedReplyDelayMs) {\n        mBatchReplyDelayMs = freshBatchedReplyDelayMs;\n    }"}
{"description": "Returns the image associated with the request URL if it has been loaded, null otherwise.", "code": "public Bitmap getImage() {\n            return mImage;\n        }"}
{"description": "Optionally specify the upper limit of records that should be returns for the request. @param upperLimit the upper limit of records that the server should return from the request @return a Builder instance, not null", "code": "public Builder withUpperLimit(final int upperLimit) {\n      _upperLimit = upperLimit;\n      return this;\n    }"}
{"description": "Optionally specify a data conversion function for the request. @param convert the data conversion method that the server should pre-process the data with @return a Builder instance, not null", "code": "public Builder withConvert(final Convert convert) {\n      ArgumentChecker.notNull(convert, \"convert\");\n      _convert = convert;\n      return this;\n    }"}
{"description": "Optionally specify the arrangement sequence of the results. @param arrangementSequence the arrangement sequence of the results @return a Builder object onto which you can chain additional calls", "code": "public Builder withArrangementSequence(final ArrangementSequence arrangementSequence) {\n      ArgumentChecker.notNull(arrangementSequence, \"arrangementSequence\");\n      _arrangementSequence = arrangementSequence;\n      return this;\n    }"}
{"description": "Write the supplier info to the CommunicationBuffer @param info the communication buffer to which we're serializing", "code": "@Override\n    public void writeTo(final CommunicationBuffer info) {\n        info.writeInt(this.infoType);\n    }"}
{"description": "Get the size of the supplier information. This implementation will typically be the parent class for another class that will override this to return the total supplier information size. This implementation just returns the size of the portion that contains the 8-byte integer data type value at the start of the supplier information.", "code": "@Override\n    public int getSize() {\n        return 8;\n    }"}
{"description": "Read the supplier info from the ConnectionBuffer @param info the connection buffer from which we're deserializing @param size the size to the end of the enclosing message", "code": "@Override\n    public void readFrom(final ConnectionBuffer info, final int size) {\n        this.infoType = info.readInt();\n    }"}
{"description": "Write the supplier info to the ChannelBuffer @param info the channel buffer to which we're serializing", "code": "@Override\n    public void writeTo(final ChannelBuffer info) {\n        info.writeInt(this.infoType);\n    }"}
{"description": "Provides means to compare if two cron expressions are identical. @param cronConverter - converts 'cron' parameter to this instance definition; @param cron - any cron instance, never null @return boolean - true if identical; false otherwise.", "code": "public boolean identical(CronConverter cronConverter, Cron cron){\n        return toString().equals(cronConverter.convert(cron).toString());\n    }"}
{"description": "Provides means to check if two cron expressions are identical. Assumes same cron definition. @param cron - any cron instance, never null @return boolean - true if identical; false otherwise.", "code": "public boolean identical(Cron cron){\n        return toString().equals(cron.toString());\n    }"}
{"description": "Sets how many milliseconds a call in {@link RiotApiAsync} waits for a reply at most before timing out. This value can be set to zero to disable the request timeout. By default, the timeout duration for asynchronous requests is 10 seconds. <p> To set the timeout for synchronous requests use {@link #setRequestTimeout(int)} instead. </p> @param timeout The maximum duration for an asynchronous call to wait for a reply until it times out @return This ApiConfig object for chaining @throws IllegalArgumentException If the timeout value is less than {@code 0}", "code": "public ApiConfig setAsyncRequestDuration(int asyncRequestDuration) {\n\t\tif (asyncRequestDuration < 0) {\n\t\t\tthrow new IllegalArgumentException(\"The timeout value must be greater than or equal to 0\");\n\t\t}\n\t\tthis.asyncRequestDuration = asyncRequestDuration;\n\t\treturn this;\n\t}"}
{"description": "Sets whether the diagnostic log should be stored in a file @param diagnosticToFile {@code true} if the diagnostic log should be stored in a file @return This ApiConfig object for chaining", "code": "public ApiConfig setDiagnosticToFile(boolean diagnosticToFile) {\n\t\tthis.diagnosticToFile = diagnosticToFile;\n\t\treturn this;\n\t}"}
{"description": "Sets whether the api should attempt to automatically obey rate restrictions. If set to {@code true}, the api will listen to rate-limit-specific headers from the Riot Api and try to obey them. @param obeyRateLimit {@code true} if the api should attempt to automatically obey rate restrictions @return This ApiConfig object for chaining", "code": "public ApiConfig setObeyRateLimit(boolean obeyRateLimit) {\r\n\t\tthis.obeyRateLimit = obeyRateLimit;\r\n\t\treturn this;\r\n\t}"}
{"description": "Returns <tt>true</tt> if this job was terminated before it finished normally. If you are calling {@link #halt(boolean)} on the task, the value returned by this method should be verified periodically from {@link #executeInBackground(Object[])} to stop the job as soon as possible. @return <tt>true</tt> if job was terminated before it finished @see #halt(boolean)", "code": "public final boolean isTerminated() {\n        return mTerminated.get();\n    }"}
{"description": "Pauses if needed for the calculation to finish, and then fetches its outcome. @return The derived outcome. @throws java.util.concurrent.CancellationException If the calculation was aborted. @throws java.util.concurrent.ExecutionException If the calculation threw an error. @throws InterruptedException If the current thread was disrupted while pausing.", "code": "public final Outcome fetch() throws InterruptedException, ExecutionException {\n        return mTask.fetch();\n    }"}
{"description": "Waits if necessary for at most the specified duration for the calculation to finish, and then fetches its outcome. @param duration Time to wait before aborting the operation. @param measure The time measure for the duration. @return The calculated outcome. @throws java.util.concurrent.CancellationException If the calculation was aborted. @throws java.util.concurrent.ExecutionException If the calculation threw an exception. @throws InterruptedException If the current thread was interrupted while waiting. @throws java.util.concurrent.TimeoutException If the wait timed out.", "code": "public final Outcome fetch(long duration, TimeMeasure measure) throws InterruptedException,\n            ExecutionException, TimeoutException {\n        return mTask.fetch(duration, measure);\n    }"}
{"description": "Performs the operation with the given arguments. The operation returns itself (this) so that the invoker can maintain a reference to it. <p>Note: this function queues the operation on a queue for a single background thread or group of threads depending on the platform version. When initially introduced, AsyncTasks were performed sequentially on a single background thread. Starting with {@link android.os.Build.VERSION_CODES#DONUT}, this was modified to a group of threads permitting multiple operations to run concurrently. Starting {@link android.os.Build.VERSION_CODES#HONEYCOMB}, operations are back to being performed on a single thread to prevent typical application mistakes caused by concurrent execution. If you genuinely want concurrent execution, you can use the {@link #performOnExecutor} version of this method with {@link #THREAD_POOL_EXECUTOR}; however, see commentary there for cautions on its use. <p>This method must be called on the UI thread. @param arguments The arguments of the operation. @return This instance of AsyncTask. @throws IllegalStateException If {@link #getStatus()} returns either {@link net.bither.image.cache.AsyncTask.Status#RUNNING} or {@link net.bither.image.cache.AsyncTask.Status#FINISHED}. @see #performOnExecutor(java.util.concurrent.Executor, Object[]) @see #execute(Runnable)", "code": "public final AsyncTask<Params, Progress, Result> perform(Params... arguments) {\n        return performOnExecutor(sDefaultExecutor, arguments);\n    }"}
{"description": "Convenience version of {@link #run(Object...)} for use with a simple Runnable object. See {@link #run(Object[])} for more information on the order of execution. @see #run(Object[]) @see #runOnExecutor(java.util.concurrent.Executor, Object[])", "code": "public static void run(Runnable runnable) {\n        sDefaultExecutor.run(runnable);\n    }"}
{"description": "Insert a fresh choice to the catalog of choices we take @param choice the fresh choice @return ourselves so that you may chain the calls", "code": "public Getopt insertChoice(CommandLineChoice choice) {\n        choices.add(choice);\n        return this;\n    }"}
{"description": "Get the position of the initial non-parameter choice. @return The index in the parameter array for the initial non-parameter choice", "code": "public int getParamPos() {\n        return paramPos;\n    }"}
{"description": "Convert the parameter to a <code>Boolean</code> @param ctx the context at the point in the expression when the function is called @param arguments a list with exactly one element which will be converted to a <code>Boolean</code> @return the result of evaluating the function; <code>Boolean.TRUE</code> or <code>Boolean.FALSE</code> @throws FunctionCallException if <code>arguments</code> has more or less than one element", "code": "public Object invoke(Context ctx,\n                       List arguments) throws FunctionCallException\n    {\n        if ( arguments.size() == 1 )\n        {\n            return evaluate( arguments.get(0), ctx.getNavigator() );\n        }\n\n        throw new FunctionCallException(\"boolean() requires one parameter\");\n    }"}
{"description": "Set if wave animation has to be positioned in its parent view or not, default is False @param isPositioned", "code": "public void setPositioned(final Boolean isPositioned)\n    {\n        this.isPositioned = isPositioned;\n    }"}
{"description": "Sets the base package that will be searched for classes to build for tag names that have no defined package. @param basePackage The base package. This will be prepended to the tag name, so it should end with a period.", "code": "public void setBasePackage(String basePackage) {\n        mBasePackage = basePackage;\n    }"}
{"description": "Returns the base package, or null if it is not set. @see #setBasePackage(String) @return The base package.", "code": "public String getBasePackage() {\n        return mBasePackage;\n    }"}
{"description": "Return the present manufacturer (or null). This is invoked on every element title. If the manufacturer yields an item, append that to the structure. If it yields null, continue to call onGenerateItem(title).", "code": "public final Manufacturer<T> getManufacturer() {\n        return mManufacturer;\n    }"}
{"description": "This procedure is accountable for generating the proper derived class of component given the xml element identifier. Override it to manage personalized component instances. If you override this in your derived class be certain to invoke through to super.onCreateComponent(identifier) for identifiers you do not recognize. @param identifier The fully qualified class identifier of the component to be generate. @param properties An AttributeSet of properties to apply to the component. @return The component generated.", "code": "protected T onCreateComponent(String identifier, AttributeSet properties) throws ClassNotFoundException {\n        return createComponent(identifier, mDefaultPackage, properties);\n    }"}
{"description": "Fetches a layout with the given layout folder identifier and layout identifier. @param layoutFolderId the given layout folder identifier @param layoutId the given layout identifier @return layout", "code": "protected Layout fetchLayout(final String layoutFolderId, final String layoutId) {\n        return Layouts.fetchLayout(layoutFolderId, layoutId);\n    }"}
{"description": "Add a record into the designated {@code dataset} and alert any registered queries. @see SQLiteDatabase#insert(String, String, ContentValues) TODO @WorkerThread", "code": "public long insert(@NonNull String dataset, @NonNull ContentValues data) {\n    return insert(dataset, data, CONFLICT_NONE);\n  }"}
{"description": "An identifier for the sequence. This can be utilized after render time to obtain a reference to the sequence object via chart.fetch(). @param identifier the id to set @return", "code": "public Sequence setIdentifier(String identifier) {\n        this.identifier = identifier;\n        return this;\n    }"}
{"description": "The title of the series as displayed in the legend, tooltip etc. @param title the title to set @return", "code": "public Series setTitle(String title) {\n        this.title = title;\n        return this;\n    }"}
{"description": "Reads the specified file, converting {@link IOException} to a {@link RuntimeException} of some sort. @param filePath {@code non-null;} path of the file to read @return {@code non-null;} contents of the file", "code": "public static byte[] readFile(String filePath) {\n        File file = new File(filePath);\n        return readFile(file);\n    }"}
{"description": "Returns an KBState enum which describes whether <code>identifierOrName</code> exists in the KB and is an instance of <code>#$Individual</code>. @param identifierOrName either the name or HL ID of an entity in the KB @return an enum describing the existential state of the entity in the KB", "code": "public static KbState getState(String identifierOrName)  {\n    return KbObjectFactory.getState(identifierOrName, QuantifierImpl.class);\n\n  }"}
